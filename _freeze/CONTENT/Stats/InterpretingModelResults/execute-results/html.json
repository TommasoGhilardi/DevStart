{
  "hash": "d715ff9681a89c87ebc8740deda7d9fe",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Interpreting Model Results\"\n\nauthor: \"Tommaso Ghilardi\"\nauthor-meta: \"Tommaso Ghilardi\"\n\nexecute:\n  eval: true\n\ndescription-meta: \"Learn what a the summary of a linear model means!\"\nkeywords-meta: \"R, lm, Linear models, statistics, analysis, psychology, tutorial, experiment, DevStart, developmental science\"\n\ndrafts: True\ndraft-mode: unlinked\n---\n\n\n\nIn the previous tutorial we run our first model and we checked whether the model met the assumptions. You have to agree it was easy and fun! Now the real challenge begins.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'ggplot2' was built under R version 4.3.3\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'tidyr' was built under R version 4.3.3\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'readr' was built under R version 4.3.3\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'dplyr' was built under R version 4.3.3\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'stringr' was built under R version 4.3.3\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(easystats)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'easystats' was built under R version 4.3.3\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n# Attaching packages: easystats 0.7.3 (red = needs update)\n✖ bayestestR  0.14.0   ✖ correlation 0.8.5 \n✔ datawizard  0.13.0   ✖ effectsize  0.8.9 \n✖ insight     0.20.5   ✖ modelbased  0.8.8 \n✖ performance 0.12.3   ✖ parameters  0.22.2\n✔ report      0.5.9    ✔ see         0.9.0 \n\nRestart the R-Session and update packages with `easystats::easystats_update()`.\n```\n\n\n:::\n\n```{.r .cell-code}\ndf = read.csv(\"..\\\\..\\\\resources\\\\Stats\\\\LM_SimulatedData.csv\")\nmod = lm(performance ~ time*tool, data = df)\n```\n:::\n\n\n\n# Interpreting the results\n\nVery cool!! we have our result!!\n\nBut what is it saying?? As you can see the summary is divided in subsections. Lets go trough them piece by piece.\n\n-   **Call**:\n\n    This section just report the function call that we passed to `lm()`.\n\n-   **Residuals**:\n\n    This section reports the residuals of the model. Residuals represent the difference between the observed values and the values predicted by the model. Essentially, how much variability remains after fitting our variable to the model.\n\n-   **Coefficients**:\n\n    This section displays the estimated coefficients of the regression model,the stand error of the estimation, the t-value and finally the p-value!\n\n-   **Model Fit:**\n\n    The last section reports different statistics about the model fit:\n\n    -   **Residual standard error:** Average distance between observed values and the regression line. Smaller is better.\n\n    -   **Multiple R-Squared:** Proportion of response variable variance explained by predictors. Ranges from 0 to 1; closer to 1 is better.\n\n    -   **Adjusted R-squared:** R-squared modified for the number of predictors. Useful for comparing models with different numbers of predictors.\n\n    -   **F-statistic and p-value:** Indicate if the model provides a better fit than a model with no predictors. A p-value \\< 0.05 suggests the model is useful.\n\n## Coeffiecients\n\nThe Coefficient section if indubitably the most important section of the summary of our model. However what are all these numbers? Let's go together through the most challenging information:\n\n### (Intercept)\n\nThe intercept often confuses who approaches for the first time linear models. What is it? The (Intercept) represent the reference levels where all our predictors (`time` and `tool`) are 0. Now you may ask...how can `tool` be 0? It is a categorical variable, it can't be 0!!!! `time == 0`...sure ....but `tool`??\n\nYou are correct. When a model encounters a categorical variable it selects the first level of such variable as reference level. If you take another look to our model summary you can see that there are information both for the `hammer`and `spoon` level of the `tool`variable but nothing about the `brush` level. This is because the `brush` level has been selected by the model as the reference level and it is thus represented in the intercept value!\n\nwe can simply visualize it as:\\\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\n\nmodel_p = parameters(mod)\n\n# Define intercept and slope for the brush\nintercept_brush <- model_p[1,2]\nintercept_brush_se <- model_p[1,3]\n\n# To create estimates\ntime_values <- seq(0, 10, by = 0.5)\n\n\nggplot()+\n  \n  # Cartesian lines\n  geom_vline(xintercept = 0, lwd =0.4) +\n\n  geom_point(aes(x=0, y=intercept_brush), size=3, color = 'darkred')+\n  geom_errorbar(aes(x=0, y=intercept_brush, ymin= intercept_brush-intercept_brush_se, ymax= intercept_brush+intercept_brush_se), color = 'darkred', lwd=1.3)+\n  \n  # Plot addition information\n  coord_cartesian(xlim = c(-1,5), ylim = c(-1,5))+\n  labs(y = 'Performance', x = 'Time')+\n  theme_bw(base_size = 20)+\n  scale_x_continuous(\n    breaks = c(0),              # The x-values where you want ticks\n    labels = c(\"0\\nBrush\")  # Corresponding custom labels\n  )\n```\n\n::: {.cell-output-display}\n![](InterpretingModelResults_files/figure-html/unnamed-chunk-2-1.png){width=2400}\n:::\n:::\n\n\n\nAs you can see, the intercept is pretty straightforward—it gives us the estimate when everything is set to 0, both for continuous and categorical variables. It’s like the starting point of your model, where all the predictors (in this case, `brush` was selected as the reference or 0 level for the categorical variable) are at their reference level or baseline value.\n\n### Tools\n\nAwesome! Now that we’ve got the intercept down, let’s take a look at the rest of the model output. We’ll skip over the `time` variable for now and focus on what’s happening with the tools.\n\nAt first, the results for `tool [hammer]` and `tool [spoon]` might look like they’re giving us the values for the hammer and spoon. Super easy, right?\n\nWell... not exactly!\n\nIn linear models, each coefficient shows the difference in relation to the intercept (the 0 or the reference level), not the exact value of the tool itself.\n\nIt sounds a bit confusing, but let’s break it down. The coefficient for `tool [hammer]` is actually just the difference between the intercept (2.81) and the coefficient for `tool [hammer]` (3.60). So, hammer’s total value = 2.81 + 3.60 = 6.41! Same goes for the spoon, where the total is 2.81 + 2.79 = 5.60.\n\nSee? Not too bad! Let’s visualize it and make it even clearer!\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define intercept and slope for the brush\nintercept_brush <- model_p[1,2]\nintercept_brush_se <- model_p[1,3]\n\nintercept_hammer <- model_p[3,2] + intercept_brush\nintercept_hammer_se <- model_p[3,3]\n\nintercept_spoon <- model_p[4,2]+ intercept_brush\nintercept_spoon_se <- model_p[4,3]\n\n\nggplot() +\n  \n  # Cartesian lines\n  geom_vline(xintercept = 0, lwd =0.4) +\n\n  # Intercept (brush)\n  geom_point(aes(x=0, y=intercept_brush), size=3, color = 'darkred')+\n  geom_errorbar(aes(x=0, y=intercept_brush, ymin= intercept_brush-intercept_brush_se, ymax= intercept_brush+intercept_brush_se), color = 'darkred', lwd=1.3)+\n  \n  # Hammer\n  geom_point(aes(x=1, y=intercept_hammer), size=3, color = 'darkblue')+\n  geom_errorbar(aes(x=1, y=intercept_hammer, ymin= intercept_hammer-intercept_hammer_se, ymax= intercept_hammer+intercept_hammer_se), color = 'darkblue', lwd=1.3)+\n  \n  # Spoon\n  geom_point(aes(x=2, y=intercept_spoon), size=3, color = 'darkgreen')+\n  geom_errorbar(aes(x=2, y=intercept_spoon, ymin= intercept_spoon-intercept_spoon_se, ymax= intercept_spoon+intercept_spoon_se), color = 'darkgreen', lwd=1.3)+\n\n  \n  # Set the limits for x and y axes\n  coord_cartesian(xlim = c(-.5,2.5), ylim = c(-1,10))+\n  \n  # Customize x-axis breaks\n  scale_x_continuous(breaks = c(0, 1, 2), labels = c('0\\nBrush','Hammer','Spoon')) +\n  \n  # Labels and theme\n  labs(y = 'Performance', x = 'Tools') +\n  theme_bw(base_size = 20)\n```\n\n::: {.cell-output-display}\n![](InterpretingModelResults_files/figure-html/unnamed-chunk-3-1.png){width=2400}\n:::\n:::\n\n\n\n### Time\n\nSo, interpreting the coefficients for categorical variables wasn’t too tricky, right? But what about continuous variables like `time`?\n\nNo worries, it’s actually pretty straightforward! The coefficient for a continuous variable represents the slope, or the incline, of the line for that variable.\n\nIn simpler terms, it shows how much the outcome (in this case, `performance`) changes for each unit increase in the continuous variable (`time`). So, in our case the coefficient for `time` is 0.04, this means that for each unit increase in `time`, the performance is expected to increase by 0.04 units (assuming all other variables stay the same).\n\nEven easier..let's plot again!\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(geomtextpath)\n\nintercept_brush    <- model_p[1,2]\nintercept_brush_se <- model_p[1,3]\n\nslope_brush    <- model_p[2,2]\nslope_brush_se <- model_p[2,3]\n\n# Some hypothetical time values\ntime_values <- seq(-1, 4, by = 0.25)\n\n# Create a small data frame for the main (brush) line\ndf_brush <- data.frame(\n  time            = time_values,\n  est_performance_brush = intercept_brush + slope_brush * time_values\n)\n\nggplot() +\n  # Dashed reference lines\n  geom_vline(xintercept = 0, lwd =0.4) +\n  geom_hline(yintercept = intercept_brush, linetype = \"dashed\", color = \"darkgray\") +\n  \n  # The main 'brush' line\n  geom_line(data = df_brush, aes(x = time, y = est_performance_brush), color = \"#e04d01\", size  = 1) +\n  \n  # Intercept (brush) point & error bar\n  geom_point(\n    aes(x = 0, y = intercept_brush),\n    size  = 3,\n    color = \"darkred\"\n  ) +\n  geom_errorbar(\n    aes(\n      x    = 0,\n      y    = intercept_brush,\n      ymin = intercept_brush - intercept_brush_se,\n      ymax = intercept_brush + intercept_brush_se\n    ),\n    color = \"darkred\",\n    size  = 1.3\n  ) +\n  \n  # Label for the intercept\n  annotate(\"text\", x = -0.5, y = 2.825, label = \"(Intercept)\") +\n  \n  # Curved arrow with a slight horizontal offset (x != xend)\n  # geom_textcurve(\n  #   # Start at (2.99, 2.83), end at (3.01, 2.89)\n  #   # so there's enough horizontal length to create a \"belly.\"\n  #   aes(\n  #     x    = 2.99,  y    = 2.83,\n  #     xend = 3.01,  yend = 3.2\n  #   ),\n  #   label     = expression(beta ~ \"Time\"),  # or \"\\u03B2 Time\"\n  #   curvature = .4,  # how “bendy” the arc is\n  #   arrow = arrow(\n  #     ends   = \"both\"),\n  #   colour = \"#e04d01\",\n  #   size   = 4,\n  #   lwd    = 1.2\n  # ) +\n  \n  # Labels and theme\n  labs(y = 'Performance', x = 'Time') +\n  theme_bw(base_size = 20)\n```\n\n::: {.cell-output-display}\n![](InterpretingModelResults_files/figure-html/unnamed-chunk-4-1.png){width=2400}\n:::\n:::\n\n\n\n### Interaction\n\nAlright, now we're getting to the final steps! Let's talk about the interaction between `time` and `tool`! Now, we're not just dealing with a single factor or continuous variable, but looking at how they interact with each other. Don't worry—if you understood the previous steps, this will be a breeze!\n\nWe'll take it step by step and look at the first interaction we see in our model parameters. Let’s start by checking out the interaction between `time` and `tool [hammer]`.\n\nThe interaction term between `time` and `tool [hammer]` tells us how the relationship between `time` and `performance` changes when we switch from the reference tool (`brush`) to the hammer. To put it simply, the coefficient for this interaction will show you how much more (or less) the effect of `time` on `performance` changes when using the hammer compared to the baseline (`brush`). If the coefficient is positive, it means that as `time` increases, `performance` increases more when using the hammer than when using the brush. If it’s negative, it means the performance increase is smaller with the hammer than with the brush.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(geomtextpath)\n\nintercept_brush    <- model_p[1,2]\nintercept_brush_se <- model_p[1,3]\n\nslope_brush    <- model_p[2,2]\nslope_brush_se <- model_p[2,3]\n\nslope_hammer = model_p[5,2]\nslope_hammer_se = model_p[5,3]\n\nslope_spoon = model_p[6,2]\nslope_spoon_se = model_p[6,3]\n\n# Some hypothetical time values\ntime_values <- seq(-1, 4, by = 0.25)\n\n# Create a small data frame for the main (brush) line\ndf_brush <- data.frame(\n  time            = time_values,\n  est_performance_brush = intercept_brush + slope_brush * time_values,\n  est_performance_hammer = intercept_brush + (slope_brush + slope_hammer) * time_values,\n  est_performance_spoon = intercept_brush + (slope_brush + slope_spoon) * time_values\n\n)\n\n\n\nggplot()+\n  \n  # Dashed reference lines\n  geom_vline(xintercept = 0, lwd =0.4) +\n  geom_hline(yintercept = intercept_brush, linetype = \"dashed\", color = \"darkgray\") +\n  \n  # The main 'brush' line\n  geom_line(data = df_brush, aes(x = time, y = est_performance_brush), color = \"#e04d01\", size  = 1) +\n  geom_line(data = df_brush, aes(x = time, y = est_performance_hammer), color = \"darkblue\", size  = 1)+\n  geom_line(data = df_brush, aes(x = time, y = est_performance_spoon), color = \"darkgreen\", size  = 1)+\n\n  \n  theme_bw(base_size = 20)+\n  labs(y='Performance', x='Time')\n```\n\n::: {.cell-output-display}\n![](InterpretingModelResults_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "InterpretingModelResults_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}