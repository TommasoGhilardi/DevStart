{
  "hash": "7202889646b7a532eefb1335c60163f8",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Linear mixed effect modesl\"\ndate: \"15/03/2025\"\n\nauthor-meta: \"Tommaso Ghilardi\"\n# description-meta: \" A concise and practical tutorial on running linear mixed-effects models in R. Learn how to handle nested data structures, interpret model summaries, and compare models using real-life examples.\"\n# keywords-meta: \"linear mixed-effects models, R, mixed models, hierarchical modeling, lme4, lmerTest, random effects, fixed effects, statistical analysis, data analysis, model comparison, AIC, Simpson's paradox, tutorial\"\n\ncategories:\n  - R\n  - Stats\n  - Mixed effects models\n---\n\n```{=html}\n<div style=\"display: flex; align-items: center;\">\n    <div style=\"flex: 1; text-align: left;\">\n        <p>Welcome to this introduction to Linear Mixed-effects Models (LMM)!! In this tutorial we will use R to run some simple LMM and we will try to understand together how to leverage these model for our analysis.\n        LMMs are amazing tools that have saved our asses countless times during our PhDs and Postdocs. They'll probably continue to be our trusty companions forever.</p>\n    </div>\n    <div style=\"flex: 0 0 auto; margin-left: 10px;\">\n        <iframe src=\"https://giphy.com/embed/ygCtKUnKEW5F6LruQd\" width=\"100\" height=\"100\" frameborder=\"0\" allowfullscreen></iframe>\n        <p style=\"margin: 0;\"><a href=\"https://giphy.com/gifs/TheBearFX-ygCtKUnKEW5F6LruQd\"></a></p>\n    </div>\n</div>\n```\n\n\n\n::: callout-note\nThis tutorial offers a gentle introduction to running linear mixed-effects models without diving deep into the mathematical and statistical foundations. If you're interested in exploring those aspects further, plenty of online resources are available.\n\nFor the best experience, you should have already completed the [**previous tutorial on linear models**](LinearModels.qmd). That foundation will make this tutorial much easier to follow and understand!\n:::\n\nThis tutorial introduces the statistical concept of Hierarchical Modeling, often called Mixed Effects Modeling. This approach shines when dealing with nested dataâ€”situations where observations are grouped in meaningful ways, like students within schools or measurements across individuals.\n\nSounds like a mouthful, right? Donâ€™t worry! Letâ€™s kick things off with something a little more fun: Simpsonâ€™s Paradox.\n\nSimpson's Paradox is a statistical head-scratcher. Itâ€™s when a trend you see in your data suddenly flipsâ€”or even vanishesâ€”when you split the data into groups. Ready to see it in action? Letâ€™s dive in!\n\nImagine weâ€™re looking at how years of experience impact salary at a university. Hereâ€™s some simulated data to make it fun.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlibrary(easystats)\nlibrary(tidyverse)\nlibrary(patchwork)\nset.seed(1234)\ndata <- simulate_simpson(n = 10, groups = 5, r = 0.5,difference = 1.5) %>% \n  mutate(V2= (V2 +abs(min(V2)))*10000) %>% \n  rename(Department = Group)\n\n# Lookup vector: map old values to new ones\nlookup <- c(G_1 = \"Informatics\", G_2 = \"English\", \n            G_3 = \"Sociology\", G_4 = \"Biology\", G_5 = \"Statistics\")\n\n# Replace values using the lookup vector\ndata$Department <- lookup[as.character(data$Department)]\n\n\none = ggplot(data, aes(x = V1, y = V2)) +\n  geom_point()+\n  geom_smooth(method = 'lm')+\n  labs(y='Salary', x='Year of experience', title = \"A. Linear model\")+\n  theme_bw(base_size = 20)\n\ntwo = ggplot(data, aes(x = V1, y = V2)) +\n  geom_point(aes(color = Department)) +\n  geom_smooth(aes(color = Department), method = \"lm\", alpha = 0.3) +\n  geom_smooth(method = \"lm\", alpha = 0.3)+\n  labs(y='Salary', x='Year of experience', title = \"B. Linear model acounting for grouping structure\")+\n  theme_bw(base_size = 20)+\n  theme(legend.position = 'bottom')\n\n(one / two)\n```\n\n::: {.cell-output-display}\n![](LinearMixedModels_files/figure-html/SimpsonParadox-1.png){width=960}\n:::\n:::\n\n\n\nTake a look at the first plot. Whoa, wait a minuteâ€”this says the more years of experience you have, the less you get paid! What kind of backwards world is this? Before you march into HR demanding answers, letâ€™s look a little closer.\n\nNow, check out the second plot. Once we consider the departmentsâ€”Informatics, English, Sociology, Biology, and Statisticsâ€”a different story emerges. Each department shows a positive trend between experience and salary. In other words, more experience does mean higher pay, as it should!\n\nSo what happened? The first plot ignored the hierarchical structure of the data. By lumping all departments together, it completely missed the real relationship hiding in plain sight. This is why Hierarchical Modeling is so powerfulâ€”it helps us avoid embarrassing statistical blunders like this one. It allows us to correctly analyze data with nested structures and uncover the real patterns.\n\n**Now, this example is a bit of an extreme case.** In real life, youâ€™re less likely to find such wildly opposite effects. However, the influence of grouping structures on your analysis is very realâ€”and often subtle. Ignoring them can lead to misleading conclusions.\n\nReady to explore how Mixed Effects Modeling helps us account for these nested structures? Letâ€™s dive in and get hands-on!\n\n### Mixed effects models\n\nSo, why are they called **mixed effects models**? Itâ€™s because these models combine two types of effects: **fixed effects** and **random effects**....... And now youâ€™re wondering what those are, donâ€™t worryâ€”I've got you! ðŸ˜…\n\nRemember how departments (Informatics, English, Sociology, etc.) completely changed the story about experience and salary? Thatâ€™s exactly where fixed and random effects come in.\n\n-   **Fixed effects** capture the consistent, predictable trends in your dataâ€”like the relationship between experience and salary across all departments. These are the big-picture patterns youâ€™re curious about and want to analyze.\n\n-   **Random effects**, on the other hand, account for the variability within groupsâ€”like how salaries differ between departments. Youâ€™re not deeply analyzing these differences, but you know theyâ€™re there, and ignoring them could mess up your results.\n\nWithout accounting for random effects, itâ€™s like assuming every department is exactly the sameâ€”and weâ€™ve already seen how misleading that can be!\n\n**The model will estimate the fixed and random effects** but donâ€™t worryâ€”the model wonâ€™t get super complex. The estimates and p-values will primarily focus on the **fixed effects**, but it will account for the **random effects** in the background to make sure the results are accurate. In other words, random effects are variables that you know contribute to the variance in your model, and you want to account for them, but youâ€™re not directly interested in obtaining a result about each one.\n\nGot the gist? Great! Now enough with words...letâ€™s dive into a real example and see these mixed effects in action!\n\n## Settings and data\n\nIn this section, we'll set up our working environment by loading the necessary libraries and importing the dataset. You'll likely already have this dataset available if you completed the previous linear models tutorial. If not, don't worryâ€”you can easily download it using the link below:\n\n\n\n```{=html}\n{{< downloadthis ../../resources/Stats/Dataset.csv label=\"Dataset.csv\" type=\"secondary\" >}}\n```\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(lme4)\nlibrary(lmerTest)\n\nlibrary(tidyverse)\nlibrary(easystats)\n```\n:::\n\n\n\nThe `lme4` package is the go-to library for running Linear Mixed Models (LMM) in R. To make your life easier, there's also the `lmerTest` package, which enhances `lme4` by allowing you to extract p-values and providing extra functions to better understand your models. In my opinion, you should always use `lmerTest` alongside `lme4`â€”it just makes everything smoother!\n\nTo run our Linear Mixed Effects Model, these are the key packages we'll use. On top of that, the `tidyverse` suite will help with data wrangling and visualization, while `easystats` will let us easily extract and summarize the important details from our models. Letâ€™s get started!\n\n### Read the data\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf = read.csv(\"..\\\\..\\\\resources\\\\Stats\\\\Dataset.csv\")\ndf$Id = factor(df$Id) # make sure subject_id is a factor\n```\n:::\n\n\n\nAfter importing the data, we've ensured that Id is treated as a factor rather than a numerical column. The importance of this distinction will become clear as we progress through the tutorial!\n\n## Linear Model\n\nWhile we already seen how to run a linear model we will rerun it here as a comparison to the next steps. In case something is not clear about this `lm()` please go back to the [**previous tutorial on linear models**](LinearModels.qmd)**.**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod_lm = lm(LookingTime ~ Event_trial*Event, data = df)\nsummary(mod_lm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = LookingTime ~ Event_trial * Event, data = df)\n\nResiduals:\n   Min     1Q Median     3Q    Max \n-772.0 -159.7   -6.1  190.5  607.1 \n\nCoefficients:\n                         Estimate Std. Error t value Pr(>|t|)    \n(Intercept)             1390.1655    29.1769  47.646   <2e-16 ***\nEvent_trial               -7.5998     2.9897  -2.542   0.0113 *  \nEventReward               99.8279    39.3360   2.538   0.0114 *  \nEvent_trial:EventReward    0.1332     3.7240   0.036   0.9715    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 253.2 on 656 degrees of freedom\n  (140 observations deleted due to missingness)\nMultiple R-squared:  0.05147,\tAdjusted R-squared:  0.04713 \nF-statistic: 11.87 on 3 and 656 DF,  p-value: 1.417e-07\n```\n\n\n:::\n:::\n\n\n\nWe wonâ€™t delve into the details of the model results in this tutorial, as we have already cover it in the previous one. However we want to point one thing about the data we run it on!!\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t800 obs. of  5 variables:\n $ Id          : Factor w/ 20 levels \"1\",\"2\",\"3\",\"4\",..: 1 1 1 1 1 1 1 1 1 1 ...\n $ Event       : chr  \"NoReward\" \"NoReward\" \"NoReward\" \"NoReward\" ...\n $ Event_trial : int  1 2 3 4 5 6 7 8 9 10 ...\n $ ReactionTime: num  344 362 406 395 382 ...\n $ LookingTime : num  1140 1156 1074 1107 991 ...\n```\n\n\n:::\n:::\n\n\n\nWait a minute! Look at our data - we have an **Id** column! ðŸ‘€ This column tells us which participant each trial belongs to. As each subject experienced all trial conditions, we have multiple data points per person. This is similar to the departments in the previous example...its a grouping variable\n\n**Wait..but then we should have taken it into consideration!!!**\n\nInstead there was nothing about **Id** in our `lm()`...there is nothing in the formula about **Id**....\n\nYes we did not account for this grouping structure...let's fix that!! But how do we do so? Well, at this point it's obvious...with Mixed effects models!! Let's dive in..\n\n## Mixed Effects\n\n### Random Intercept\n\nAlright, letâ€™s start with **Random Intercepts**! What are they? Well, the name gives it awayâ€”theyâ€™re just interceptsâ€¦but with a twist! ðŸ¤”\n\nIf you recall your knowledge of linear models, youâ€™ll remember that each model has **one intercept**â€”the point where the model crosses the y-axis (when x=0).\n\nBut what makes random intercepts special? They allow the model to have **different intercepts for each grouping variable**â€”in this case, the **Id**s. This means weâ€™re letting the model assume that each subject may have a slightly different baseline performance.\n\nHereâ€™s the idea:\n\n-   One person might naturally be a bit better.\n\n-   Someone else could be slightly worse.\n\n-   And me? Well, letâ€™s just say Iâ€™m starting from rock bottom.\n\nHowever, even though weâ€™re starting from different baselines, **the rate of improvement over trials can still be consistent across subjects**.\n\nThis approach helps us capture **variation in the starting performance**, acknowledging that people are inherently different but might still follow a similar overall pattern of improvement. Itâ€™s a simple yet powerful way to model individual differences!\n\nNow, letâ€™s look at how to include this in our mixed model.\n\n#### Model\n\nTo run a **linear mixed-effects model**, weâ€™ll use the `lmer` function from the **lme4** package. it Functions very similarly to the `lm` function we used before: you pass a formula and a dataset, but with one important addition: specifying the **random intercept**.\n\nThe formula is nearly the same as a standard linear model, but we include `(1|subject_id)` to tell the model that each subject should have its own unique intercept. This accounts for variations in baseline performance across individuals.\n\n::: callout-caution\nWhen specifying random intercepts (like `(1|Group)`), your grouping variables must be factors! If a grouping variable is numeric, R will wrongly treat it as a continuous variable rather than discrete categories. Character variables are automatically fine, but numeric grouping variables must be explicitly converted using `factor()`.\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod_rintercept =lmer(LookingTime ~ Event_trial * Event+ (1|Id ), data= df,  na.action = na.exclude)\nsummary(mod_rintercept)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nLinear mixed model fit by REML. t-tests use Satterthwaite's method [\nlmerModLmerTest]\nFormula: LookingTime ~ Event_trial * Event + (1 | Id)\n   Data: df\n\nREML criterion at convergence: 7672.4\n\nScaled residuals: \n    Min      1Q  Median      3Q     Max \n-3.4289 -0.6265  0.0007  0.6061  4.1655 \n\nRandom effects:\n Groups   Name        Variance Std.Dev.\n Id       (Intercept) 61071    247.13  \n Residual              5669     75.29  \nNumber of obs: 660, groups:  Id, 20\n\nFixed effects:\n                         Estimate Std. Error        df t value Pr(>|t|)    \n(Intercept)             1402.8087    55.9446   19.8464  25.075  < 2e-16 ***\nEvent_trial              -10.6377     0.9222  637.2807 -11.536  < 2e-16 ***\nEventReward               86.4541    11.7345  637.0258   7.368 5.41e-13 ***\nEvent_trial:EventReward    3.2757     1.1326  637.1760   2.892  0.00396 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nCorrelation of Fixed Effects:\n            (Intr) Evnt_t EvntRw\nEvent_trial -0.130              \nEventReward -0.116  0.621       \nEvnt_trl:ER  0.106 -0.812 -0.846\n```\n\n\n:::\n:::\n\n\n\nWow! Now the model is showing us something **new** compared to the simple linear model. We observe an **interaction between Event and Event_trial**. By letting the intercept vary for each subject, the model is able to capture nuances in the data that a standard linear model might miss.\n\nTo understand this interaction, letâ€™s plot it and see how performance changes across trials for each condition.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ni_pred = estimate_expectation(mod_rintercept, include_random=T)\n\nggplot(i_pred, aes(x= Event_trial, y= Predicted, color= Id, shape = Event))+\n    geom_point(data = df, aes(y= LookingTime, color= Id), position= position_jitter(width=0.2))+\n    geom_line()+\n    geom_ribbon(aes(ymin=Predicted-SE, ymax=Predicted+SE, fill = Id),color= 'transparent', alpha=0.1)+\n    labs(y='Looking time', x='# trial')+\n    theme_modern(base_size = 20)+\n    theme(legend.position = 'none')+\n    facet_wrap(~Event)\n```\n\n::: {.cell-output-display}\n![](LinearMixedModels_files/figure-html/unnamed-chunk-4-1.png){width=1152}\n:::\n:::\n\n\n\nAs you can see here, each color represents a different subject, and we've divided the plot into two panels - one for each type of event - to make visualization simpler. Cool isn't it??.\n\nNow, you might be thinking, *â€œThis looks interesting, but my plot is going to be a mess with all these individual estimates!â€* Well, donâ€™t worry! While what weâ€™ve plotted is how the data is modeled by our mixed-effects model, the random effects are actually used to make more accurate estimatesâ€”but the model still returns an overall estimate.\n\nThink of it like this: the random effects allow the model to account for individual differences between subjects. But instead of just showing all the individual estimates in the plot, the model takes these individual estimates for each subject and returns the *average* of these estimates to give you a cleaner, more generalizable result.\n\nwe can plot the actual estimate of the model:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ni_pred = estimate_expectation(mod_rintercept, include_random =F)\n\nggplot(i_pred, aes(x= Event_trial, y= Predicted))+\n    geom_point(data = df, aes(y= LookingTime, color= Id, shape = Event), position= position_jitter(width=0.2))+\n    geom_line(aes(group= Event),color= 'blue', lwd=1.4)+\n    geom_ribbon(aes(ymin=Predicted-SE, ymax=Predicted+SE, group= Event),color= 'transparent', alpha=0.1)+\n    labs(y='Looking time', x='# trial')+\n    theme_bw(base_size = 20)+\n  theme(legend.position = 'none')+\n  facet_wrap(~Event)\n```\n\n::: {.cell-output-display}\n![](LinearMixedModels_files/figure-html/PlotInterceptModelOverall-1.png){width=1152}\n:::\n:::\n\n\n\n### Slope\n\nCoool!!!!!!! So far, weâ€™ve modeled a different intercept for each subject, which lets each subject have their own baseline level of performance. But hereâ€™s the catch: our model assumes that everyone improves over the trials in exactly the same way, with the same slope. That doesnâ€™t sound quite right, does it? We know that some people may get better faster than others, or their learning might follow a different pattern.\n\n#### Model\n\nThis is where we can model *random slopes* to capture these individual differences in learning rates. By adding `(0 + Event_trial | Id)`, weâ€™re telling the model that while the intercept (starting point) is the same for everyone, the rate at which each subject improves (the slope) can vary.\n\nThis way, weâ€™re allowing each subject to have their own slope in addition to their own intercept, making the model more flexible and reflective of real-world variations in learning!\n\n::: callout-caution\nAny variable used as a random slope (before the `|`) must also be included as a fixed effect in your model. The fixed effect estimates the overall effect, while the random slope captures how that effect varies across groups. Without the fixed effect, you're modeling deviations from zero instead of from an average, which rarely makes theoretical sense.\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod_rslope =lmer(LookingTime ~ Event_trial * Event+ (0 + Event_trial | Id ), data= df)\nsummary(mod_rslope)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nLinear mixed model fit by REML. t-tests use Satterthwaite's method [\nlmerModLmerTest]\nFormula: LookingTime ~ Event_trial * Event + (0 + Event_trial | Id)\n   Data: df\n\nREML criterion at convergence: 8208.6\n\nScaled residuals: \n    Min      1Q  Median      3Q     Max \n-3.9794 -0.5260 -0.0366  0.5164  3.2475 \n\nRandom effects:\n Groups   Name        Variance Std.Dev.\n Id       Event_trial   447.6   21.16  \n Residual             13205.8  114.92  \nNumber of obs: 660, groups:  Id, 20\n\nFixed effects:\n                        Estimate Std. Error       df t value Pr(>|t|)    \n(Intercept)             1407.153     13.480  637.385 104.386  < 2e-16 ***\nEvent_trial              -11.747      4.956   22.512  -2.370  0.02674 *  \nEventReward               80.551     18.013  637.185   4.472 9.18e-06 ***\nEvent_trial:EventReward    4.628      1.781  638.075   2.599  0.00958 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nCorrelation of Fixed Effects:\n            (Intr) Evnt_t EvntRw\nEvent_trial -0.249              \nEventReward -0.746  0.185       \nEvnt_trl:ER  0.689 -0.245 -0.844\n```\n\n\n:::\n:::\n\n\n\nThe results aren't too different from the intercept-only model, but let's take a closer look at what we've actually modeled.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ns_pred = estimate_expectation(mod_rslope, include_random =T)\n\nggplot(s_pred, aes(x= Event_trial, y= Predicted, color= Id, shape = Event))+\n    geom_point(data = df, aes(y= LookingTime, color= Id), position= position_jitter(width=0.2))+\n    geom_line()+\n    geom_ribbon(aes(ymin=Predicted-SE, ymax=Predicted+SE, fill = Id),color= 'transparent', alpha=0.1)+\n    labs(y='Looking time', x='# trial')+\n    theme_modern(base_size = 20)+\n    theme(legend.position = 'none')+\n    facet_wrap(~Event)\n```\n\n::: {.cell-output-display}\n![](LinearMixedModels_files/figure-html/PlotSlopeModel-1.png){width=1152}\n:::\n:::\n\n\n\n### Intercept + Slope\n\nThat plot does look nuts, and itâ€™s a clear signal that something is off. Why? Because by modeling only the random slopes while keeping the intercepts fixed, weâ€™re essentially forcing all subjects to start from the same baseline. Thatâ€™s clearly unrealistic for most real-world data.\n\nIn real life, the intercept and slope often go hand-in-hand for each subject.\n\n#### Model\n\nTo make the model more realistic, we can model both the random intercept and the random slope together. We simply modify the random effects part of the formula to `(trial_number | subject_id)`.\n\nNow, we are telling the model to estimate both a random intercept (baseline performance) and a random slope (rate of improvement). This captures the full variability in how each subject learns over time!\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod_rinterraction = lmer(LookingTime ~ Event_trial * Event+ (1 + Event_trial | Id ), data= df)\nsummary(mod_rinterraction)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nLinear mixed model fit by REML. t-tests use Satterthwaite's method [\nlmerModLmerTest]\nFormula: LookingTime ~ Event_trial * Event + (1 + Event_trial | Id)\n   Data: df\n\nREML criterion at convergence: 6955.7\n\nScaled residuals: \n     Min       1Q   Median       3Q      Max \n-3.10408 -0.69312 -0.01849  0.66571  2.84041 \n\nRandom effects:\n Groups   Name        Variance Std.Dev. Corr\n Id       (Intercept) 45370    213.00       \n          Event_trial   125     11.18   0.11\n Residual              1631     40.39       \nNumber of obs: 660, groups:  Id, 20\n\nFixed effects:\n                         Estimate Std. Error        df t value Pr(>|t|)    \n(Intercept)             1408.2817    47.8672   19.2207  29.421  < 2e-16 ***\nEvent_trial              -11.6324     2.5547   20.2049  -4.553 0.000189 ***\nEventReward               79.4614     6.3566  618.4483  12.501  < 2e-16 ***\nEvent_trial:EventReward    4.5126     0.6306  619.3686   7.156 2.36e-12 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nCorrelation of Fixed Effects:\n            (Intr) Evnt_t EvntRw\nEvent_trial  0.088              \nEventReward -0.075  0.128       \nEvnt_trl:ER  0.069 -0.170 -0.844\n```\n\n\n:::\n:::\n\n\n\nNow, letâ€™s visualize how the model is modeling the data:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nis_pred = estimate_expectation(mod_rinterraction, include_random =T)\n\nggplot(is_pred, aes(x= Event_trial, y= Predicted, color= Id, shape = Event))+\n    geom_point(data = df, aes(y= LookingTime, color= Id), position= position_jitter(width=0.2))+\n    geom_line()+\n    geom_ribbon(aes(ymin=Predicted-SE, ymax=Predicted+SE, fill = Id),color= 'transparent', alpha=0.1)+\n    labs(y='Looking time', x='# trial')+\n    theme_modern(base_size = 20)+\n    theme(legend.position = 'none')+\n    facet_wrap(~Event)\n```\n\n::: {.cell-output-display}\n![](LinearMixedModels_files/figure-html/PlotInterceptSlopeModel-1.png){width=1152}\n:::\n:::\n\n\n\nWhile is not super apparent from the data you can see that different subject have different slopes meaning that they all not grow at the same rate\n\n## Summary of mixed models\n\nNow that we've seen how to run mixed-effects models, it's time to focus on **interpreting the summary output**. While weâ€™ve been building models, we havenâ€™t delved into what the summary actually tells us or which parts of it deserve our attention. Letâ€™s fix that!\n\nTo start, weâ€™ll use our **final model** and inspect its summary. This will give us a chance to break it down step by step and understand the key information it provides. Here's how to check the summary:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(mod_rinterraction)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nLinear mixed model fit by REML. t-tests use Satterthwaite's method [\nlmerModLmerTest]\nFormula: LookingTime ~ Event_trial * Event + (1 + Event_trial | Id)\n   Data: df\n\nREML criterion at convergence: 6955.7\n\nScaled residuals: \n     Min       1Q   Median       3Q      Max \n-3.10408 -0.69312 -0.01849  0.66571  2.84041 \n\nRandom effects:\n Groups   Name        Variance Std.Dev. Corr\n Id       (Intercept) 45370    213.00       \n          Event_trial   125     11.18   0.11\n Residual              1631     40.39       \nNumber of obs: 660, groups:  Id, 20\n\nFixed effects:\n                         Estimate Std. Error        df t value Pr(>|t|)    \n(Intercept)             1408.2817    47.8672   19.2207  29.421  < 2e-16 ***\nEvent_trial              -11.6324     2.5547   20.2049  -4.553 0.000189 ***\nEventReward               79.4614     6.3566  618.4483  12.501  < 2e-16 ***\nEvent_trial:EventReward    4.5126     0.6306  619.3686   7.156 2.36e-12 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nCorrelation of Fixed Effects:\n            (Intr) Evnt_t EvntRw\nEvent_trial  0.088              \nEventReward -0.075  0.128       \nEvnt_trl:ER  0.069 -0.170 -0.844\n```\n\n\n:::\n:::\n\n\n\nThe **Random effects** section in the model summary shows how variability is accounted for by the random effects. The **Groups** column indicates the grouping factor (e.g., subject), while the **Name** column lists the random effects (e.g., intercept and slope). The **Variance** column represents the variability for each random effectâ€”higher values indicate greater variation in how the effect behaves across groups. The **Std.Dev.** column is simply the standard deviation of the variance, showing the spread in the same units as the data.\n\nThe **Corr** column reflects the correlation between random effects, telling us whether different aspects of the data (e.g., intercepts and slopes) tend to move together. A negative correlation would suggest that higher intercepts (starting points) are associated with smaller slopes (slower learning rates), while a positive correlation would suggest the opposite.\n\nThe **Residual** section shows the unexplained variability after accounting for the fixed and random effects.\n\n**The key takeaway here is that random effects capture the variability in the data that canâ€™t be explained by the fixed effects alone.** If the variance for a random effect is low, it suggests the random effect isnâ€™t adding much to the model and may be unnecessary. On the other hand, high variance indicates that the random effect is important for capturing group-level differences and improving the modelâ€™s accuracy.\n\n## Model comparison\n\nBut how can we be sure the random effects are helping our model? One of the easiest ways is to check the variance explained by the random effects. As we said if the variance related to the random effects is too small, it probably isnâ€™t contributing much to the model. If itâ€™s high, itâ€™s likely helping the model by capturing important variability in the data.\n\nAnother method is to compare the performance of different models. One of the best indices for this is the Akaike Information Criterion (AIC). AIC gives a relative measure of how well a model fits the data, while penalizing the number of parameters in the model. Lower AIC values indicate better models, as they balance goodness-of-fit with model complexity.\n\nYou can compare the AIC of different models using the following:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncompare_performance(mod_lm, mod_rintercept, mod_rslope, mod_rinterraction, metrics='AIC')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Comparison of Model Performance Indices\n\nName              |           Model |  AIC (weights)\n----------------------------------------------------\nmod_lm            |              lm | 9184.1 (<.001)\nmod_rintercept    | lmerModLmerTest | 7702.4 (<.001)\nmod_rslope        | lmerModLmerTest | 8241.1 (<.001)\nmod_rinterraction | lmerModLmerTest | 6990.1 (>.999)\n```\n\n\n:::\n:::\n\n\n\nAs you can see, the best model based on AIC is the one with both intercept and slope. This is a good way to check if and which random effect structure is necessary for our model.\n\n::: callout-warning\nNever decide if your random effect structure is good by just looking at p-values! P-values are not necessarily related to how well the model fits your data. Always use model comparison and fit indices like AIC to guide your decision.\n:::\n\n## Formulary\n\nIn this tutorial, we introduced linear mixed-effects models. However, these models can be far more versatile and complex than what we've just explored. The `lme4` package allows you to specify various models to suit diverse research scenarios. While we wonâ€™t dive into every possibility, hereâ€™s a handy reference for the different random effects structures you can specify\n\n\n\n```{=html}\n<table border=\"1\" style=\"width: 100%; border-collapse: collapse;\">\n  <thead>\n    <tr>\n      <th style=\"white-space: nowrap;\">Formula</th>\n      <th>Description</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td style=\"white-space: nowrap;\">(1|s)</td>\n      <td>Random intercepts for unique level of the factor <code>s</code>.</td>\n    </tr>\n    <tr>\n      <td style=\"white-space: nowrap;\">(1|s) + (1|i)</td>\n      <td>Random intercepts for each unique level of <code>s</code> and for each unique level of <code>i</code>.</td>\n    </tr>\n    <tr>\n      <td style=\"white-space: nowrap;\">(1|s/i)</td>\n      <td>\n        Random intercepts for factor <code>s</code> and <code>i</code>, where the random effects for <code>i</code> are nested in <code>s</code>. \n        This expands to <code>(1|s) + (1|s:i)</code>, i.e., a random intercept for each level of <code>s</code>, and each unique combination of the levels of <code>s</code> and <code>i</code>. \n        Nested random effects are used in so-called multilevel models. For example, <code>s</code> might refer to schools, and <code>i</code> to classrooms within those schools.\n      </td>\n    </tr>\n    <tr>\n      <td style=\"white-space: nowrap;\">(a|s)</td>\n      <td>\n        Random intercepts and random slopes for <code>a</code>, for each level of <code>s</code>. Correlations between the intercept and slope effects are also estimated. \n        (Identical to <code>(a*b|s)</code>.)\n      </td>\n    </tr>\n    <tr>\n      <td style=\"white-space: nowrap;\">(a*b|s)</td>\n      <td>\n        Random intercepts and slopes for <code>a</code>, <code>b</code>, and the <code>a:b</code> interaction, for each level of <code>s</code>. \n        Correlations between all the random effects are estimated.\n      </td>\n    </tr>\n    <tr>\n      <td style=\"white-space: nowrap;\">(0+a|s)</td>\n      <td>Random slopes for <code>a</code> for each level of <code>s</code>, but no random intercepts.</td>\n    </tr>\n    <tr>\n      <td style=\"white-space: nowrap;\">(a||s)</td>\n      <td>\n        Random intercepts and random slopes for <code>a</code>, for each level of <code>s</code>, but no correlations between the random effects (i.e., they are set to 0). \n        This expands to: <code>(0+a|s) + (1|s)</code>.\n      </td>\n    </tr>\n  </tbody>\n</table>\n```\n",
    "supporting": [
      "LinearMixedModels_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}