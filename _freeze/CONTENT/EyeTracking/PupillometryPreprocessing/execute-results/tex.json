{
  "hash": "cb25ca74ccc86f34a2a152f2e45ebac6",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Pupillometry\"\n  \nauthor-meta: \"Tommaso Ghilardi\"\ndescription-meta: \"Learn the fundamentals of pupil dilation processing using PupillometryR\"\nkeywords: \"pupil dilation, pupillometry, eye-tracking, experiments, infant research, DevStart, developmental science\"\ncategories:\n  - Pupillometry\n  - R\nlightbox: true\n\n\nhtml:\n  embed-resources: true\n  \nformat:\n  pdf:\n    fig-width: 40\n    fig-height: 20\n    fig.dpi: 300\n    code-block-width: auto  # Set to auto to dynamically adjust width\n    keep-md: true\n    header-includes: |\n      \\usepackage{fvextra}\n      \\DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines,commandchars=\\\\\\{\\},fontsize=\\small}\n---\n\n\n\n\nWelcome to your first step into the world of pupillometry! In this tutorial, we’ll walk you through how to preprocess pupil data using a handy R package called [PupillometryR](http://samforbes.me/PupillometryR/index.html). This package makes it simple to clean and even analyze your pupil data with just a few lines of R code.\n\nTo keep things straightforward, we’ll be working with a simulated dataset that you can download right here (insert link). This dataset is based on the experimental design we introduced earlier in our eye-tracking series. If you’re not familiar with it or need a quick refresher, we recommend checking out the \"[Introduction to eye-tracking](Intro_eyetracking.qmd)\" guide before diving in.\n\nThis tutorial serves as a foundation for understanding how to preprocess pupil data. Once you've grasped the essentials, we encourage you to explore the full range of functions and features [PupillometryR](http://samforbes.me/PupillometryR) has to offer.\n\n## Read the data\n\nLet's begin by importing the necessary libraries and loading the downloaded dataframe.\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\nPerfect now let's read our dataframe\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRaw_data = read.csv(\"..\\\\..\\\\resources\\\\Pupillometry\\\\PupilData.csv\")\nhead(Raw_data) # database peak\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  X   Subject      Time   PupilL   PupilR   Events TrialN\n1 1 Subject_1  1.000000 3.704922 3.298884 Fixation      1\n2 2 Subject_1  4.333526 3.697448 3.292230     <NA>     NA\n3 3 Subject_1  7.667052 3.679314 3.276083     <NA>     NA\n4 4 Subject_1 11.000578 3.702009 3.296291     <NA>     NA\n5 5 Subject_1 14.334104 3.686186 3.282202     <NA>     NA\n6 6 Subject_1 17.667630 3.712768 3.305871     <NA>     NA\n```\n\n\n:::\n:::\n\n\n\n\nOur dataframe consists of several easily interpretable columns. **Time** represents elapsed time in milliseconds, **Subject** identifies the participant, and **Events** indicates when and which stimuli were presented. **TrialN** tracks the trial number, while **PupilL** and **PupilR** measure pupil dilation for the left and right eyes, respectively, in millimeters.\n\nLet's plot the data! Visualizing it first is always a crucial step as it provides an initial understanding of its structure and key patterns.\n\n\n\n\n::: {.cell warnings='false'}\n\n```{.r .cell-code}\nggplot(Raw_data, aes(x = Time, y = PupilR))+\n  geom_line(aes(y = PupilR, color = 'Pupil Right'), lwd = 1.2) +\n  geom_line(aes(y = PupilL, color = 'Pupil Left'), lwd = 1.2) +\n  geom_vline(data = Raw_data |> dplyr::filter(!is.na(Events)) , aes(xintercept = Time, color = Events), linetype = 'dashed') +\n\n  facet_wrap(~Subject)+\n  theme_bw(base_size = 35)+\n  ylim(1,6)+\n  scale_color_manual(values = c('Pupil Right' = '#4A6274', 'Pupil Left' = '#E2725A'))+\n  theme(legend.position = 'bottom') +\n  guides(color = guide_legend(override.aes = list(lwd = 20)))  # Make legend lines thicker\n```\n\n::: {.cell-output-display}\n![](PupillometryPreprocessing_files/figure-pdf/PlotRaw-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n## Prepare the data\n\nNow that we've visualized the data, you’ve probably noticed two things:\n\n1.  **So many events!** That’s intentional — it’s better to have too many triggers than miss something important. But don’t worry, for our pupil dilation analysis, we only care about two key events: **Circle** and **Square** (check the paradigm intro if you need a refresher on why that is).\n\n2.  **Single-sample events!** Like in most studies, events are marked at a single time point (when the stimulus is presented). But PupilometryR needs a different structure — it expects the event value to be repeated for every row while the event is happening.\n\nSo, how do we fix this? First, let’s isolate the rows in our dataframe where the events are **Circle** or **Square**. We start by creating a list of the events we care about, then use it to filter our dataframe and keep only the rows related to those events in a new dataframe called Events\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nEvents_to_keep = c('Circle','Square')\nEvents = filter(Raw_data, Events %in% Events_to_keep) # filter data\nhead(Events) # database peak\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      X   Subject       Time   PupilL   PupilR Events TrialN\n1   221 Subject_1   734.3757       NA       NA Circle      1\n2  2552 Subject_1  8504.8248 3.288117 2.927758 Square      2\n3  4883 Subject_1 16275.2739 2.926076 2.605395 Circle      3\n4  7215 Subject_1 24049.0565 3.463782 3.084172 Circle      4\n5  9546 Subject_1 31819.5055 3.433078 3.056833 Square      5\n6 11877 Subject_1 39589.9546 3.890758 3.464353 Circle      6\n```\n\n\n:::\n:::\n\n\n\n\nPerfect! Now onto the second point: we need to repeat the events we just selected for the entire duration we want to analyze. But what’s this duration? We want to cover the full cue presentation (2 seconds), plus an extra 0.5 seconds before the stimulus appears. Why? This pre-stimulus period will serve as our baseline, which we’ll use later in the analysis.\n\nSo, let’s define how much time to include before and after the stimulus. We’ll also set the framerate of our data (**300Hz**) and create a time vector that starts from the pre-stimulus period and continues in steps of 1/Hz, with a total length equal to Pre_stim + Post_stim. In addition we also create a copy of our raw data called Trial_data. We do this so the original data stays intact, and all our edits happen on the copy\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Settings to cut events\nPre_stim = 100 # pre stimulus time\nPost_stim = 2000 # post stimulus time\nFs = 300 # framerate\n\nTime = seq(from = -Pre_stim, by=1000/Fs, length.out = (Pre_stim+Post_stim)/1000*300-1) # time vector\n\n# create copy of the raw data\nTrial_data = Raw_data \n```\n:::\n\n\n\n\nHere’s where the magic happens. We loop through each event listed in our **Events** dataframe. Each row in Events corresponds to a specific event (like a \"Circle\" or \"Square\" cue) that occurred for a specific subject during a specific trial.\n\nFor each event, we extract three key details:\n\n-   **Subject** (to know which participant the event is for)\n\n-   **Event** (to know if it's a Circle or Square cue)\n\n-   **TrialN** (to know which trial this event is part of)\n\nNext, we identify the rows of interest in our dataframe. We look for rows where the Subject matches the current participant, and the Time falls within the window from Pre_stim to Post_stim relative to the event's start.\n\nFinally, we use these identified rows to add the event information. The Time, Event, and TrialN values are repeated across all the rows in this window, ensuring every row in the event window is properly labeled.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Loop for each event of each subject\nfor (trial in 1:nrow(Events)){\n\n    # Extract the information\n    Sub = Events[trial, 'Subject']\n    Event = Events[trial, 'Events']\n    TrialN = Events[trial, 'TrialN']\n    Onset = Events[trial, 'Time']\n\n    \n    # Find the rows to update based on subject and time\n    rows_to_update = which(Trial_data$Subject == Sub &\n                           Trial_data$Time >= (Onset - Pre_stim) &\n                           Trial_data$Time < (Onset + Post_stim))\n   \n    # Repeat the values of interest for all the rows\n    Trial_data[rows_to_update, 'Time'] = Time\n    Trial_data[rows_to_update, 'Events'] = Event\n    Trial_data[rows_to_update, 'TrialN'] = TrialN\n}\n```\n:::\n\n\n\n\nPerfect! We’ve successfully extended the event information backward and forward based on our Pre_stim and Post_stim windows. Now, it’s time to clean things up.\n\nSince we only care about the rows that are part of our trial of interest, we’ll remove all the rows that don’t belong to these event windows. This will leave us with a clean, focused dataset that only contains the data relevant to our analysis.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTrial_data = Trial_data %>% \n    filter(Events %in% Events_to_keep)\n```\n:::\n\n\n\n\nVery good job reaching to this point!! if you believe it or not this was the hardest part!! We have now our different dataset!! let's take a look:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nggplot(Trial_data, aes(x = Time, y = PupilR, group = TrialN)) +\n  geom_line(aes(y = PupilR, color = 'Pupil Right'), lwd = 1.2) +\n  geom_line(aes(y = PupilL, color = 'Pupil Left'), lwd = 1.2) +\n  geom_vline(aes(xintercept = 0), linetype = 'dashed', color = 'black', lwd = 1.2) +\n  facet_wrap(~Subject) +\n  \n  ylim(1, 6) +\n  scale_color_manual(values = c('Pupil Right' = '#4A6274', 'Pupil Left' = '#E2725A')) +\n  \n  theme_bw(base_size = 35) +\n  theme(\n    legend.position = 'bottom', \n    legend.title = element_blank()) +\n  guides(color = guide_legend(override.aes = list(lwd = 20))) \n```\n\n::: {.cell-output-display}\n![](PupillometryPreprocessing_files/figure-pdf/PlotEvents-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n### Make pupillometryR data\n\nOk, now it’s time to start working with **PupillometryR**! 🎉\n\nIn the previous steps, we changed our event structure, and you might be wondering — why all that effort? Well, it’s because PupillometryR needs the data in this specific format to do its magic. To get started, we’ll pass our dataframe to the `make_pupillometryr_data()` function. If you’re already thinking, “Oh no, not another weird object type that’s hard to work with!” — don't worry! The good news is that the main object it creates is just a regular dataframe. That means we can still interact with like we’re used to. This makes the pre-processing steps much less frustrating. Let’s get started!\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Trial_data[Trial_data$Subject == 'Subject_1' & Trial_data$TrialN==1,]$PupilL = NA\n# Trial_data[Trial_data$Subject == 'Subject_1' & Trial_data$TrialN==1,]$PupilR = NA\n# Trial_data[Trial_data$Subject == 'Subject_4' & Trial_data$TrialN==1,]$PupilL = NA\n# Trial_data[Trial_data$Subject == 'Subject_4' & Trial_data$TrialN==1,]$PupilR = NA\n\nPupilR_data = make_pupillometryr_data(data = Trial_data,\n                                 subject = Subject,\n                                 trial = TrialN,\n                                 time = Time,\n                                 condition = Events)\n```\n:::\n\n\n\n\nHere, we’re simply using the **`make_pupillometryr_data()`** function to pass in our data and specify which columns contain the key information. This tells PupillometryR where to find the crucial details, like subject IDs, events, and pupil measurements, so it knows how to structure and process the data properly.\n\n::: callout-tip\nIf you have extra columns that you want to keep in your **PupillometryR** data during preprocessing, you can pass them as a list using the **`other = c(OtherColumn1, OtherColumn2)`** argument. This allows you to keep these additional columns alongside your main data throughout most of the preprocessing steps.\n\nBut here’s a heads-up — not all functions can keep these extra columns every time. For example, downsampling may not retain them since it reduces the number of rows, and it’s not always clear how to summarize extra columns. So, keep that in mind as you plan your analysis!\n:::\n\n#### Plot\n\nOne cool feature of the data created using **`make_pupillometryr_data()`** is that it comes with a simple, built-in `plot` function. This makes it super easy to visualize your data without needing to write tons of code. The plot function works by averaging the data over the `group` variable. So we can group over subject or condition. Here we use the `group` variable to focus on the **condition** and average over the subjec.\n\nIn this example, we’re plotting the PupilL (left pupil) data, grouped by condition. The `plot()` function is actually just a ggplot2 wrapper, which means you can customize to a certain extent like any other ggplot. That’s why we can add elements to it, like **`theme_bw()`**, which gives the plot a cleaner, black-and-white look. Give it a go without adding anything and then learn to customize it!!\n\n::: callout-tip\n**Pro tip!** If you want more control over your plots, you can always use ggplot2. Remember, the Pupil data is just a regular dataframe, so you can plot it in any way you like!\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(PupilR_data, pupil = PupilL, group = 'condition', geom = 'line') +\n  theme_bw(base_size = 45) +\n  theme(\n    legend.position = 'bottom', \n    legend.title = element_blank()) +\n  guides(color = guide_legend(override.aes = list(lwd = 20))) \n```\n\n::: {.cell-output-display}\n![](PupillometryPreprocessing_files/figure-pdf/Pupilplot-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n::: callout-important\nIn this tutorial, we’ll use two methods to plot our data. We’ll use the PupillometryR plot to visualize the average pupil response by condition, and we’ll also use ggplot to manually plot our data. Both approaches are valid and offer unique benefits.\n\nThe PupillometryR plot provides a quick overview by automatically averaging pupil responses across condition levels, making it ideal for high-level trend visualization. On the other hand, ggplot gives you full control to visualize specific details or customize every aspect of the plot, allowing for deeper insights and flexibility.\n:::\n\n## Pre-processing\n\nNow that we have our pupillometry data in the required format we can actually start the pre-processing!!\n\n### Regress\n\nThe first step is to regress **PupilL** against **PupilR** (and vice versa) using a simple linear regression. This corrects small inconsistencies in pupil data caused by noise. The regression is done separately for each participant, trial, and time point, ensuring smoother and more consistent pupil dilation measurements.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRegressed_data <- regress_data(data = PupilR_data,\n                                pupil1 = PupilL,\n                                pupil2 = PupilR)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `mutate()`:\ni In argument: `pupil1newkk = .predict_right(PupilL, PupilR)`.\ni In group 1: `Subject = \"Subject_1\"`, `TrialN = 1`, `Events = \"Circle\"`.\nCaused by error in `lm.fit()`:\n! 0 (non-NA) cases\n```\n\n\n:::\n:::\n\n\n\n\n**Pwa pwa pwaaaaa...!!**🤦‍♂️ We got an error!\n\nWhat’s it saying? It’s telling us that one of the trials is completely full of **NAs**, and since there’s no data to work with, the function fails. This happens **a lot** when testing infants — they don’t always do what we expect, like watching the screen. Instead, they move around or look away.\n\nWe’ll deal with missing data properly later, but for now, we need a quick fix. What can we do? We can simply drop any trials where both pupils (PupilL and PupilR) are entirely NA. This way, we avoid errors and keep the analysis moving.\n\nSo let's filter our data and then redo the last two steps (make PupilR_data and then regress data)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Filter the trial data\nTrial_data <- Trial_data %>%\n    group_by(Subject, TrialN) %>%  # group by Subject and TrialN\n    filter(!all(is.na(PupilL) & is.na( PupilR))) %>% # filter out if both PupilR and PupilL are all NA\n    ungroup()  # Remove grouping\n\n# Make pupilloemtryR data\nPupilR_data = make_pupillometryr_data(data = Trial_data,\n                                 subject = Subject,\n                                 trial = TrialN,\n                                 time = Time,\n                                 condition = Events)\n# Regress data\nRegressed_data <- regress_data(data = PupilR_data,\n                               pupil1 = PupilL,\n                                pupil2 = PupilR)\n```\n:::\n\n\n\n\nAnd now everything worked!! Perfect!\n\n### Mean pupil\n\nAs the next steps we will average the two pupil signals. This will create a new variable called mean_pupil\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nMean_data <- calculate_mean_pupil_size(data = Regressed_data, \n                                       pupil1 = PupilL, \n                                       pupil2 = PupilR)\n\nplot(Mean_data, pupil = mean_pupil, group = 'condition', geom = 'line')+\n  theme_bw(base_size = 45) +\n  theme(\n    legend.position = 'bottom', \n    legend.title = element_blank()) +\n  guides(color = guide_legend(override.aes = list(lwd = 20))) \n```\n\n::: {.cell-output-display}\n![](PupillometryPreprocessing_files/figure-pdf/MeanData-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n### Lowpass\n\nNow that we have a single pupil signal, we can move on to filtering it. The goal here is to remove fast noise and fluctuations that aren't relevant to our analysis. Why? Because we know that pupil dilation is a slow physiological signal, and those rapid changes are likely just noise from blinks, eye movements, or measurement errors. By filtering out these fast fluctuations, we can focus on the meaningful changes in pupil dilation that matter for our analysis.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfiltered_data <- filter_data(data = Mean_data,\n                             pupil = mean_pupil,\n                             filter = 'median',\n                             degree = 11)\nplot(filtered_data, pupil = mean_pupil, group = 'condition', geom = 'line')+\n  theme_bw(base_size = 45) +\n  theme(\n    legend.position = 'bottom', \n    legend.title = element_blank()) +\n  guides(color = guide_legend(override.aes = list(lwd = 20))) \n```\n\n::: {.cell-output-display}\n![](PupillometryPreprocessing_files/figure-pdf/Lowpass-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\nThere are different ways to filter the data in PupillometryR we suggest you check the actual package website and make decision based on your data ([`filter_data`](http://samforbes.me/PupillometryR/reference/filter_data.html)). Here we use a median filter based on a 11 sample window.\n\n### Downsample\n\nAs mentioned above, Pupil dilation is a slow signal, so 20Hz is enough — no need for 300Hz. Downsampling reduces file size, speeds up processing, and naturally smooths the signal by filtering out high-frequency noise, all while preserving the key information we need for analysis. To downsample to 20Hz, we’ll set the timebin size to 50 ms (since 1/20 = 0.05 seconds = 50 ms) and calculate the median for each time bin.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nNewHz = 20\ntimebinSize = 1/NewHz\n\nDownsampled_data <- downsample_time_data(data = filtered_data,\n                              pupil = mean_pupil,\n                              timebin_size = timebinSize,\n                              option = 'median')\nplot(Downsampled_data, pupil = mean_pupil, group = 'condition', geom = 'line') +\n  theme_bw(base_size = 45) +\n  theme(\n    legend.position = 'bottom', \n    legend.title = element_blank()) +\n  guides(color = guide_legend(override.aes = list(lwd = 20))) \n```\n\n::: {.cell-output-display}\n![](PupillometryPreprocessing_files/figure-pdf/Downsample-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n### Trial Rejection\n\nNow that our data is smaller and smoother, it’s a good time to take a look at it. It doesn’t make sense to keep trials that are mostly missing values, nor does it make sense to keep participants with very few good trials.\n\nWhile you might already have info on trial counts and participant performance from other sources (like video coding), PupillometryR has a super handy function to check this directly. This way, you can quickly see how many valid trials each participant has and decide which ones to keep or drop.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nMissing_data <- calculate_missing_data(Downsampled_data,\n                                       mean_pupil)\nhead(Missing_data, n=20)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 20 x 3\n   Subject   TrialN Missing\n   <chr>      <int>   <dbl>\n 1 Subject_1      2  0.111 \n 2 Subject_1      3  0.0159\n 3 Subject_1      4  0.130 \n 4 Subject_1      5  0.0541\n 5 Subject_1      6  0     \n 6 Subject_1      7  0.141 \n 7 Subject_1      8  0.132 \n 8 Subject_1      9  0     \n 9 Subject_1     10  0     \n10 Subject_2      1  0     \n11 Subject_2      2  0     \n12 Subject_2      3  0.107 \n13 Subject_2      4  0.124 \n14 Subject_2      5  0     \n15 Subject_2      6  0.0954\n16 Subject_2      7  0     \n17 Subject_2      8  0.141 \n18 Subject_2      9  0.0922\n19 Subject_2     10  0.119 \n20 Subject_3      1  0.107 \n```\n\n\n:::\n:::\n\n\n\n\nThis gives us a new dataframe that shows the amount of missing data for each subject and each trial. While we could manually decide which trials and subjects to keep or remove, PupillometryR makes it easier with the **`clean_missing_data()`** function.\n\nThis function lets you set two % thresholds — one for trials and one for subjects. Here, we’ll set it to reject trials with more than 25% missing data (keep at least 75% of the data) and reject subjects with more than 25% missing data. This way, we ensure our analysis is based on clean, high-quality data.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nClean_data <- clean_missing_data(Downsampled_data,\n                                 pupil = mean_pupil,\n                                 trial_threshold = .75,\n                                 subject_trial_threshold = .75)\n```\n:::\n\n\n\n\n::: callout-warning\nNote that this function calculates the percentage of missing trials based only on the trials present in the dataframe. For example, if a participant only completed one trial (and watched it perfectly) before the session had to stop, the percentage would be calculated on that single trial, and the participant wouldn’t be rejected.\n\nIf you have more complex conditions for excluding participants (e.g., based on total expected trials or additional criteria), you’ll need to handle this manually to ensure subjects are dropped appropriately.\n:::\n\n### Fill the signal\n\nNow our data is clean, but… while the average signal for each condition looks smooth (as seen in our plots), the data for each individual participant is still noisy. We can still spot blinks and missing data in the signal.\n\nTo handle this, we’ll use interpolation to fill in the missing points. Interpolation \"connects the dots\" between gaps, creating a more continuous and cleaner signal. This step is crucial because large chunks of missing data can distort our analysis, and interpolation allows us to retain more usable data from each participant.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(Clean_data, aes(x = Time, y = mean_pupil, group = TrialN, color= Events))+\n  geom_line( lwd =1.2)+\n  geom_vline(aes(xintercept = 0), linetype= 'dashed', color = 'black', lwd =1.2)+\n\n  facet_wrap(~Subject)+\n  ylim(1,6)+\n  \n  theme_bw(base_size = 45) +\n  theme(\n    legend.position = 'bottom', \n    legend.title = element_blank()) +\n  labs(y = 'Pupil Size')+\n  guides(color = guide_legend(override.aes = list(lwd = 20))) \n```\n\n::: {.cell-output-display}\n![](PupillometryPreprocessing_files/figure-pdf/PlotBlink-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\nSo to remove these missing values we can interpolate our data. Interpolating is easy with pupillometryR we can simply:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nInt_data <- interpolate_data(data = Clean_data,\n                             pupil = mean_pupil,\n                             type = 'linear')\n\nggplot(Int_data, aes(x = Time, y = mean_pupil, group = TrialN, color = Events))+\n  geom_line(lwd =1.2)+\n  geom_vline(aes(xintercept = 0), linetype= 'dashed', color = 'black', lwd =1.2)+\n\n  facet_wrap(~Subject)+\n  ylim(1,6)+\n  \n  theme_bw(base_size = 45) +\n  theme(\n    legend.position = 'bottom', \n    legend.title = element_blank()) +\n  labs(y = 'Pupil Size')+\n  guides(color = guide_legend(override.aes = list(lwd = 20))) \n```\n\n::: {.cell-output-display}\n![](PupillometryPreprocessing_files/figure-pdf/WrongInterpolation-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n**Done!!** Well, you’ve probably noticed something strange... When there’s a blink, the pupil signal can rapidly decrease until it’s completely missing. Right now, this drop gets interpolated, and the result is a weird, unrealistic curve where the signal dips sharply and then smoothly recovers. This makes our data look horrible! 😩\n\n**Let’s fix it!**\n\nTo do this, we’ll use PupillometryR’s blink detection functions. There are two main ways to detect blinks:\n\n1.  [**Based on size**](http://samforbes.me/PupillometryR/reference/detect_blinks_by_size.html) — detects pupil size.\n\n2.  [**Based on velocity**](http://samforbes.me/PupillometryR/reference/detect_blinks_by_velocity.html) — detects rapid changes in pupil size (which happens during blinks).\n\nHere, we’ll use detection by velocity. We set a velocity threshold to detect when the pupil size changes too quickly. To ensure we capture the full blink, we use `extend_forward` and `extend_back` to expand the blink window, including the fast decrease in pupil size. The key idea is to make the entire blink period NA, not just the moment the pupil disappears. This prevents interpolation from creating unrealistic artifacts. When we interpolate, the process skips over the entire blink period, resulting in a cleaner, more natural signal.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nBlink_data = detect_blinks_by_velocity(\n    Clean_data,\n    mean_pupil,\n    threshold = 0.1,\n    extend_forward = 50,\n    extend_back = 50)\n\nggplot(Blink_data, aes(x = Time, y = mean_pupil, group = TrialN, color=Events))+\n  geom_line(lwd =1.2)+\n  geom_vline(aes(xintercept = 0), linetype= 'dashed', color = 'black', lwd =1.2)+\n\n  facet_wrap(~Subject)+\n  ylim(1,6)+\n  \n  theme_bw(base_size = 45) +\n  theme(\n    legend.position = 'bottom', \n    legend.title = element_blank()) +\n  labs(y = 'Pupil Size')+\n  guides(color = guide_legend(override.aes = list(lwd = 20))) \n```\n\n::: {.cell-output-display}\n![](PupillometryPreprocessing_files/figure-pdf/BlinkRemoval-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\nSee !! now the rapid shrinking disappeared and we can now interpolate\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nInt_data <- interpolate_data(data = Blink_data,\n                             pupil = mean_pupil,\n                             type = 'linear')\n\nggplot(Int_data, aes(x = Time, y = mean_pupil, group = TrialN, color=Events))+\n  geom_line(lwd =1.2)+\n  geom_vline(aes(xintercept = 0), linetype= 'dashed', color = 'black', lwd =1.2)+\n\n  facet_wrap(~Subject)+\n  ylim(1,6)+\n  \n  theme_bw(base_size = 45) +\n  theme(\n    legend.position = 'bottom', \n    legend.title = element_blank()) +\n  labs(y = 'Pupil Size')+\n  guides(color = guide_legend(override.aes = list(lwd = 20))) \n```\n\n::: {.cell-output-display}\n![](PupillometryPreprocessing_files/figure-pdf/Interpolation2-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\nLook how beautiful our signal is now!! 😍 Good job!!!\n\n::: callout-caution\nIt’s not always the case that blinks will have a rapid drop in pupil size followed by missing values. Sometimes, you’ll just get missing values straight away. This can depend on the eye tracker, sampling rate, and even the population you’re testing (like infants who might look away suddenly). Because of this, blink detection may not always be necessary. The best approach is to check your data before deciding. And how do you check it? Plotting! Plotting your signal is the best way to see if blinks are causing rapid drops or if you’re just dealing with missing data. Let the data guide your decisions.\n:::\n\n### Baseline Correction\n\nGood job getting this far!! We’re now at the final step of our pre-processing: baseline correction.\n\nBaseline correction helps remove variability between trials and participants, like differences in baseline pupil size caused by individual differences, fatigue, or random fluctuations. By doing this, we can focus only on the variability caused by our paradigm. This step ensures that any changes we see in pupil size are truly driven by the experimental conditions, not irrelevant noise. Let’s get it done!\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_data <- baseline_data(data = Int_data,\n                           pupil = mean_pupil,\n                           start = -100,\n                           stop = 0)\n```\n:::\n\n\n\n\nLet's plot it to see what baseline correction is actually doing!! We will plot both the average signal using the `plot` function (with some addition inforamtion about color and theme) and using ggplot to plot the data for each subject separately.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nOne = plot(base_data, pupil = mean_pupil, group = 'condition')+\n  theme_bw(base_size = 45) +\n  theme(legend.position = 'none')\n\n\nTwo = ggplot(base_data, aes(x = Time, y = mean_pupil, group = TrialN, color = Events))+\n  geom_line(lwd =1.2)+\n  geom_vline(aes(xintercept = 0), linetype= 'dashed', color = 'black', lwd =1.2)+\n\n  facet_wrap(~Subject)+\n\n  theme_bw(base_size = 45) +\n  theme(\n    legend.position = 'bottom', \n    legend.title = element_blank()) +\n  labs(y = 'Pupil Size')+\n  guides(color = guide_legend(override.aes = list(lwd = 20))) \n\n# Using patchwork to put the plot toghether\nOne / Two\n```\n\n::: {.cell-output-display}\n![](PupillometryPreprocessing_files/figure-pdf/FinalPlot-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n### Save and analysis\n\nThis tutorial will not cover the analysis of pupil dilation. We’ll stop here since, after baseline correction, the data is ready to be explored and analyzed. From this point on, we’ll shift from **pre-processing** to **analysis**, so it’s a good idea to save the data as a simple *.csv* file for easy access and future use.\n\n\n\n\n::: {.cell eco='false'}\n\n```{.r .cell-code}\nwrite.csv('\"..\\\\..\\\\resources\\\\Pupillometry\\\\ProcessedPupilData.csv\"')\n```\n:::\n\n\n\n\nThere are multiple ways to analyze pupil data, and we’ll show you some of our favorite methods in a dedicated tutorial: **Analyze Pupil Dilation**.\n\n## All code\n\nHere below we report the whole code we went trough this tutorial as an unique scrit to make it easier for you to copy and explore it in it's entirety. We\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Setting and Libraries -----------------------------------------------------------------\n\nlibrary(PupillometryR)\nlibrary(tidyverse)\nlibrary(patchwork)\n\n\n# Read Data -----------------------------------------------------------------\n\nRaw_data = read.csv(\"..\\\\..\\\\resources\\\\Pupillometry\\\\PupilData.csv\")\n\nhead(Raw_data)\n\n## Plot Raw Data -----------------------------------------------------------------\n\nggplot(Raw_data, aes(x = Time, y = PupilR)) +\n  geom_line(aes(y = PupilR, color = 'Pupil Right'), lwd = 1.2) +\n  geom_line(aes(y = PupilL, color = 'Pupil Left'), lwd = 1.2) +\n  geom_vline(data = Raw_data |> dplyr::filter(!is.na(Events)), aes(xintercept = Time, color = Events), linetype = 'dashed') +\n  facet_wrap(~Subject) +\n  theme_bw(base_size = 35) +\n  ylim(1, 6) +\n  scale_color_manual(values = c('Pupil Right' = '#4A6274', 'Pupil Left' = '#E2725A')) +\n  theme(legend.position = 'bottom') +\n  guides(color = guide_legend(override.aes = list(lwd = 20)))\n\n\n# Prepare Data -----------------------------------------------------------------\n\n## Extract Events -----------------------------------------------------------------\n\nEvents_to_keep = c('Circle','Square')\n\nEvents = filter(Raw_data, Events %in% Events_to_keep)\n\nhead(Events)\n\n\n## Event Settings -----------------------------------------------------------------\n\nPre_stim = 100\n\nPost_stim = 2000\n\nFs = 300\n\nTime = seq(from = -Pre_stim, by = 1000 / Fs, length.out = (Pre_stim + Post_stim) / 1000 * 300 - 1)\n\nTrial_data = Raw_data\n\n\n## Extend Events -----------------------------------------------------------------\n\nfor (trial in 1:nrow(Events)) {\n  Sub = Events[trial, 'Subject']\n  Event = Events[trial, 'Events']\n  TrialN = Events[trial, 'TrialN']\n  Onset = Events[trial, 'Time']\n  rows_to_update = which(Trial_data$Subject == Sub &\n                           Trial_data$Time >= (Onset - Pre_stim) &\n                           Trial_data$Time < (Onset + Post_stim))\n  Trial_data[rows_to_update, 'Time'] = Time\n  Trial_data[rows_to_update, 'Events'] = Event\n  Trial_data[rows_to_update, 'TrialN'] = TrialN\n}\n\n\n## Filter Events -----------------------------------------------------------------\n\nTrial_data = Trial_data %>% \n  filter(Events %in% Events_to_keep)\n\n\n### Plot Events -----------------------------------------------------------------\n\nggplot(Trial_data, aes(x = Time, y = PupilR, group = TrialN)) +\n  geom_line(aes(y = PupilR, color = 'Pupil Right'), lwd = 1.2) +\n  geom_line(aes(y = PupilL, color = 'Pupil Left'), lwd = 1.2) +\n  geom_vline(aes(xintercept = 0), linetype = 'dashed', color = 'black', lwd = 1.2) +\n  facet_wrap(~Subject) +\n  ylim(1, 6) +\n  scale_color_manual(values = c('Pupil Right' = '#4A6274', 'Pupil Left' = '#E2725A')) +\n  theme_bw(base_size = 35) +\n  theme(legend.position = 'bottom', legend.title = element_blank()) +\n  guides(color = guide_legend(override.aes = list(lwd = 20)))\n\n\n# Pre-processing -----------------------------------------------------------------\n\n## Make PupillometryR Data -----------------------------------------------------------------\n\nPupilR_data = make_pupillometryr_data(data = Trial_data,\n                                      subject = Subject,\n                                      trial = TrialN,\n                                      time = Time,\n                                      condition = Events)\n\n### Plot ------------------------------------------------------------------\nplot(PupilR_data, pupil = PupilL, group = 'condition', geom = 'line') +\n  theme_bw(base_size = 45) +\n  theme(\n    legend.position = 'bottom', \n    legend.title = element_blank()) +\n  guides(color = guide_legend(override.aes = list(lwd = 20))) \n\n\n\n## Regress Data -----------------------------------------------------------------\n\nRegressed_data <- regress_data(data = PupilR_data,\n                               pupil1 = PupilL,\n                               pupil2 = PupilR)\n\n\n## Filter Out Trials with NA -----------------------------------------------------------------\n\nTrial_data <- Trial_data %>%\n  group_by(Subject, TrialN) %>%\n  filter(!all(is.na(PupilL) & is.na(PupilR))) %>%\n  ungroup()\n\nPupilR_data = make_pupillometryr_data(data = Trial_data,\n                                      subject = Subject,\n                                      trial = TrialN,\n                                      time = Time,\n                                      condition = Events)\n\nRegressed_data <- regress_data(data = PupilR_data,\n                               pupil1 = PupilL,\n                               pupil2 = PupilR)\n\n\n## Calculate Mean Pupil -----------------------------------------------------------------\n\nMean_data <- calculate_mean_pupil_size(data = Regressed_data, \n                                       pupil1 = PupilL, \n                                       pupil2 = PupilR)\n\n### Plot --------------------------------------------------------------------\n\nplot(Mean_data, pupil = mean_pupil, group = 'condition', geom = 'line')+\n  theme_bw(base_size = 45) +\n  theme(\n    legend.position = 'bottom', \n    legend.title = element_blank()) +\n  guides(color = guide_legend(override.aes = list(lwd = 20))) \n\n\n## Lowpass Filter -----------------------------------------------------------------\n\nfiltered_data <- filter_data(data = Mean_data,\n                             pupil = mean_pupil,\n                             filter = 'median',\n                             degree = 11)\n\n### Plot --------------------------------------------------------------------\n\nplot(filtered_data, pupil = mean_pupil, group = 'condition', geom = 'line')+\n  theme_bw(base_size = 45) +\n  theme(\n    legend.position = 'bottom', \n    legend.title = element_blank()) +\n  guides(color = guide_legend(override.aes = list(lwd = 20))) \n\n\n## Downsample -----------------------------------------------------------------\n\nNewHz = 20\n\ntimebinSize = 1 / NewHz\n\nDownsampled_data <- downsample_time_data(data = filtered_data,\n                                         pupil = mean_pupil,\n                                         timebin_size = timebinSize,\n                                         option = 'median')\n\n# Plot --------------------------------------------------------------------\n\nplot(Downsampled_data, pupil = mean_pupil, group = 'condition', geom = 'line') +\n  theme_bw(base_size = 45) +\n  theme(\n    legend.position = 'bottom', \n    legend.title = element_blank()) +\n  guides(color = guide_legend(override.aes = list(lwd = 20))) \n\n\n## Calculate Missing Data -----------------------------------------------------------------\n\nMissing_data <- calculate_missing_data(Downsampled_data, mean_pupil)\n\n\n## Clean Missing Data -----------------------------------------------------------------\n\nClean_data <- clean_missing_data(Downsampled_data,\n                                 pupil = mean_pupil,\n                                 trial_threshold = .75,\n                                 subject_trial_threshold = .75)\n\n### Plot --------------------------------------------------------------------\n\nggplot(Clean_data, aes(x = Time, y = mean_pupil, group = TrialN, color= Events))+\n  geom_line( lwd =1.2)+\n  geom_vline(aes(xintercept = 0), linetype= 'dashed', color = 'black', lwd =1.2)+\n  \n  facet_wrap(~Subject)+\n  ylim(1,6)+\n  \n  theme_bw(base_size = 45) +\n  theme(\n    legend.position = 'bottom', \n    legend.title = element_blank()) +\n  guides(color = guide_legend(override.aes = list(lwd = 20))) \n\n\n## Detect Blinks -----------------------------------------------------------------\n\nBlink_data = detect_blinks_by_velocity(\n  Clean_data,\n  mean_pupil,\n  threshold = 0.1,\n  extend_forward = 50,\n  extend_back = 50)\n\n### Plot --------------------------------------------------------------------\n\nggplot(Blink_data, aes(x = Time, y = mean_pupil, group = TrialN, color=Events))+\n  geom_line(lwd =1.2)+\n  geom_vline(aes(xintercept = 0), linetype= 'dashed', color = 'black', lwd =1.2)+\n  \n  facet_wrap(~Subject)+\n  ylim(1,6)+\n  \n  theme_bw(base_size = 45) +\n  theme(\n    legend.position = 'bottom', \n    legend.title = element_blank()) +\n  guides(color = guide_legend(override.aes = list(lwd = 20))) \n\n\n## Interpolate Data -----------------------------------------------------------------\n\nInt_data <- interpolate_data(data = Blink_data,\n                             pupil = mean_pupil,\n\n### Plot --------------------------------------------------------------------\n\nggplot(Int_data, aes(x = Time, y = mean_pupil, group = TrialN, color = Events))+\n  geom_line(lwd =1.2)+\n  geom_vline(aes(xintercept = 0), linetype= 'dashed', color = 'black', lwd =1.2)+\n\n  facet_wrap(~Subject)+\n  ylim(1,6)+\n  \n  theme_bw(base_size = 45) +\n  theme(\n    legend.position = 'bottom', \n    legend.title = element_blank()) +\n  guides(color = guide_legend(override.aes = list(lwd = 20)))\n\n\n# Baseline correction -----------------------------------------------------\n\nbase_data <- baseline_data(data = Int_data,\n                           pupil = mean_pupil,\n                           start = -100,\n                           stop = 0)\n\n### Final plot --------------------------------------------------------------\n\nOne = plot(base_data, pupil = mean_pupil, group = 'condition')+\n  theme_bw(base_size = 45) +\n  theme(legend.position = 'none')\n\n\nTwo = ggplot(base_data, aes(x = Time, y = mean_pupil, group = TrialN, color = Events))+\n  geom_line(lwd =1.2)+\n  geom_vline(aes(xintercept = 0), linetype= 'dashed', color = 'black', lwd =1.2)+\n  \n  facet_wrap(~Subject)+\n  \n  theme_bw(base_size = 45) +\n  theme(\n    legend.position = 'bottom', \n    legend.title = element_blank()) +\n  guides(color = guide_legend(override.aes = list(lwd = 20))) \n\nOne / Two\n\n\n\n# Save data ---------------------------------------------------------------\n\nwrite.csv('\"..\\\\..\\\\resources\\\\Pupillometry\\\\ProcessedPupilData.csv\"')\n```\n:::\n",
    "supporting": [
      "PupillometryPreprocessing_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}