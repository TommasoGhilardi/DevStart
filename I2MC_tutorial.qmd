---
title: Using I2MC for robust fixation extraction
execute:
  eval: false
  
pagetitle: Using I2MC for Robust Fix Extraction - DevStart
author-meta: Tommaso Ghilardi
description-meta: Learn how to use I2MC for robust fixation extraction in eye-tracking data analysis.
keywords: eye-tracking, I2MC, fixation detection, data analysis, tutorial, python, DevStart, developmental science, tutorial, eye fixations
---

# What we are going to do

When it comes to eye-tracking data, one of the most important things we want to figure out is fixations. Fixations are specific points in an eye-tracking dataset where a person's gaze remains relatively still and focused on a particular area or object for a period of time. These moments represent critical instances when a person's visual attention is focused on a particular point of interest.

Typically, eye-tracking programs come with their own fixation detection algorithms that give us a rough idea of what the person was looking at. But here's the problem: these tools aren't always very good when it comes to data from infants and children. Why? Because infants and children can be all over the place! They move their heads, put their hands (or even feet) in front of their faces, close their eyes, or just look away. All of this makes the data a big mess that's hard to make sense of with regular fixation detection algorithms. Because the data is so messy, it is difficult to tell which data points are part of the same fixation or different fixations.

**But don't worry! We've got a solution: I2MC.**

I2MC stands for *"Identification by Two-Means Clustering"*, and it was designed specifically for this kind of problem. It's designed to deal with all kinds of noise, and even periods of data loss. In this tutorial, we'll show you how to use I2MC to find fixations. We won't get into the nerdy stuff about how it works - this is all about the practical side. If you're curious about the science, you can read the [article](https://link.springer.com/article/10.3758/s13428-016-0822-1).

Now that we've introduced I2MC, let's get our hands dirty and see how to use it!

# Install I2MC

Installing I2MC in Python is extremely easy. As explained in the tutorial to install Python, just open the miniconda terminal, activate the environment you want to install I2MC in and type `pip install I2MC`. After a few seconds, you should be ready to go!!

::: callout-note
I2MC has been originally written for Matlab. So for you crazy people who would prefer to use Matlab you can find instructions to download and use I2MC here: [I2MC Matlab!](https://github.com/royhessels/I2MC)
:::

# Use I2MC

Let's start with importing the libraries that we will need

```{python}
import I2MC                         # I2MC
import pandas as pd                 # panda help us read csv
import numpy as np                  # to handle arrays
import matplotlib.pyplot  as plt    # to make plots
```

This was too easy now, let's start to really get into it.

## Import data

Now we will write a simple function to import our data. This step unfortunately will have to be adapted depending on the system you used to collect the data and the data structure you will have in the end. For this tutorial, you can use your data-set (probably you will have to adapt the importing function) or use our data that you can download from here LINK.

Let's create step by step our function to import the data

```{python}
# Load data
    raw_df = pd.read_csv(PATH_TO_DATA, delimiter=',')
```

After reading the data we will create a new data-frame that we will fill with the information needed from our raw_df. this is the point that would change depending on you eye-tracked and data format. you will probably have to change the columns names to be sure to have the 5 relevant ones.

```{python}
# Create empty dataframe
df = pd.DataFrame()
    
# Extract required data
df['time'] = raw_df['Time']
df['L_X'] = raw_df['LeftX']
df['L_Y'] = raw_df['LeftY']
df['R_X'] = raw_df['RightX']
df['R_Y'] = raw_df['RightY']
```

After selecting the relevant data we will perform some very basic processing. - Sometimes there could be weird peaks where one sample is (very) far outside the monitor. Here, we will count as missing any data that is more than one monitor distance outside the monitor. Tobii gives us the validity index of the measured eye, here when the validity is too low (\>1) we will consider the sample as missing

```{python}
# Sometimes we have weird peaks where one sample is (very) far outside the monitor. Here, count as missing any data that is more than one monitor distance outside the monitor.

# Left eye
lMiss1 = (df['L_X'] < -res[0]) | (df['L_X']>2*res[0])
lMiss2 = (df['L_Y'] < -res[1]) | (df['L_Y']>2*res[1])
lMiss  = lMiss1 | lMiss2 | (raw_df['ValidityLeft'] > 1)
df.loc[lMiss,'L_X'] = np.NAN
df.loc[lMiss,'L_Y'] = np.NAN

# Right eye
rMiss1 = (df['R_X'] < -res[0]) | (df['R_X']>2*res[0])
rMiss2 = (df['R_Y'] < -res[1]) | (df['R_Y']>2*res[1])
rMiss  = rMiss1 | rMiss2 | (raw_df['ValidityRight'] > 1)
df.loc[rMiss,'R_X'] = np.NAN
df.loc[rMiss,'R_Y'] = np.NAN
```

**Perfect!!!**

### Everything into a function

We have read the data, extracted the relevant information and done some extremely basic processing rejecting data that had to be considered non valid. Now we will wrap this code in a function to make it easier to use with I2MC:

```{python}
# ===================================================================
# Import data from Tobii TX300
# ===================================================================

def tobii_TX300(fname, res=[1920,1080]):
    '''
    Imports data from Tobii TX300
    
    Parameters
    ----------
    fname : string
        The file (filepath)
    res : tuple
        The (X,Y) resolution of the screen
    
    Returns
    -------
    df : pandas.DataFrame
         Gaze data, with columns:
         t : The sample times from the dataset
         L_X : X positions from the left eye
         L_Y : Y positions from the left eye
         R_X : X positions from the right eye
         R_Y : Y positions from the right eye
    '''

    # Load all data
    raw_df = pd.read_csv(fname, delimiter=',')
    df = pd.DataFrame()
    
    # Extract required data
    df['time'] = raw_df['Time']
    df['L_X'] = raw_df['LeftX']
    df['L_Y'] = raw_df['LeftY']
    df['R_X'] = raw_df['RightX']
    df['R_Y'] = raw_df['RightY']
    
    ###
    # Sometimes we have weird peaks where one sample is (very) far outside the
    # monitor. Here, count as missing any data that is more than one monitor
    # distance outside the monitor.
    
    # Left eye
    lMiss1 = (df['L_X'] < -res[0]) | (df['L_X']>2*res[0])
    lMiss2 = (df['L_Y'] < -res[1]) | (df['L_Y']>2*res[1])
    lMiss  = lMiss1 | lMiss2 | (raw_df['ValidityLeft'] > 1)
    df.loc[lMiss,'L_X'] = np.NAN
    df.loc[lMiss,'L_Y'] = np.NAN
    
    # Right eye
    rMiss1 = (df['R_X'] < -res[0]) | (df['R_X']>2*res[0])
    rMiss2 = (df['R_Y'] < -res[1]) | (df['R_Y']>2*res[1])
    rMiss  = rMiss1 | rMiss2 | (raw_df['ValidityRight'] > 1)
    df.loc[rMiss,'R_X'] = np.NAN
    df.loc[rMiss,'R_Y'] = np.NAN
    
    return(df)
```

### Find our data

Nice!! we have our import function that we will use to read our data. Now, let's find our data! To do this, we will use the glob library, which is a handy tool for finding files in Python. In the code above, we are telling Python to look for files with a *.csv* extension in a specific folder on our computer. Let's import glob and then let's find the files:

```{python}
import glob
    data_files = glob.glob('C:\\Users\\tomma\\surfdrive - Ghilardi, T. (Tommaso)@surfdrive.surf.nl\\Documentation\Working\\Eyetracking\\data\\**\\*.csv', recursive = True)
```

-   `/home/geeks/Desktop/gfg/`: This is the path where we want to start our search.
-   `\*\*`: This special symbol tells Python to search in all the subfolders (folders within folders) under our starting path.
-   `/*.csv`: We're asking Python to look for files with names ending in ".csv".
-   `recursive=True`: This option means that Python should search for files not just in the immediate subfolders but in all the subfolders within subfolders, and so on.
